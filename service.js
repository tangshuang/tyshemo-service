const { Mocker } = require('tyshemo/dist/mocker')
const { Parser } = require('tyshemo/dist/parser')
const express = require('express')
const { Ty } = require('tyshemo')
const fs = require('fs')
const path = require('path')
const { stringify, getPath } = require('./utils')

class Service {
  constructor(options = {}) {
    const { data, mockConfig, parseConfig } = options
    this.data = data
    this.mocker = new Mocker(mockConfig)
    this.parser = new Parser(parseConfig)
    this.options = options
  }

  mock(mockServerConfig = {}) {
    const app = express()

    app.use(express.json())
    app.use(express.urlencoded({ extended: true }))

    const items = []
    this.data.forEach((group) => {
      items.push(...group.items)
    })

    const {
      basePath: globalBasePath,
      getResponseType: globalGetResponseType,
      getRequestType: globalGetRequestType,
      getErrorType: globalGetErrorType,
      errorMapping: globalErrorMapping = {},
    } = this.options

    const { port = 8089 } = mockServerConfig

    items.forEach((item) => {
      const {
        method,
        path,
        request,
        response,
        basePath = globalBasePath,
        getResponseType = globalGetResponseType,
        getRequestType = globalGetRequestType,
        getErrorType = globalGetErrorType,
        errorMapping = {},
      } = item

      const url = (basePath ? basePath : '') + path

      app[method](url, (req, res) => {
        // check req data
        if (request) {
          const data = method === 'get' ? req.query : req.body
          const reqPattern = getRequestType ? getRequestType(request) : request
          const type = Ty.create(reqPattern)
          const err = Ty.catch(data).by(type)
          if (err) {
            const { message } = err
            const errType = getErrorType ? getErrorType(message) : { message }
            const errJson = this.mocker(errType)
            res.status(499)
            res.json(errJson)
            return
          }
        }

        // give mock data for response
        const resPattern = getResponseType ? getResponseType(response) : response
        const type = Ty.create(resPattern)
        const data = this.mocker.mock(type)
        res.json(data)
      })
    })

    app.listen(port)
  }

  doc(docServerConfig = {}) {
    const {
      basePath: globalBasePath,
      getResponseType: globalGetResponseType,
      getRequestType: globalGetRequestType,
      getErrorType: globalGetErrorType,
      errorMapping: globalErrorMapping = {},
    } = this.options

    const { port = 8088, title = 'TySheMo', description = 'This is an api doc generated by TySheMo.' } = docServerConfig

    const data = this.data.map((group) => {
      const { items } = group
      return {
        ...group,
        items: items.map((item) => {
          const {
            name,
            description,
            method,
            path,
            request,
            response,
            basePath = globalBasePath,
            getResponseType = globalGetResponseType,
            getRequestType = globalGetRequestType,
            getErrorType = globalGetErrorType,
            errorMapping = {},
          } = item

          const random = '************' + Math.random() + '***********'

          const reqPattern = getRequestType ? getRequestType(request) : request
          const reqType = reqPattern ? Ty.create(reqPattern) : null
          const reqDesc = reqType ? this.parser.describe(reqType) : null
          const reqCommentRoot = getRequestType ? getPath(getRequestType(random), random) : ''
          const reqComments = request ? request.__comments : {}
          const reqText = reqDesc ? stringify(reqDesc, reqComments, reqCommentRoot) : ''

          const resPattern = getResponseType ? getResponseType(response) : response
          const resType = resPattern ? Ty.create(resPattern) : null
          const resDesc = resType ? this.parser.describe(resType) : null
          const resCommentRoot = getResponseType ? getPath(getResponseType(random), random) : ''
          const resComments = response ? response.__comments : {}
          const resText = resDesc ? stringify(resDesc, resComments, resCommentRoot) : ''

          const errPattern = getErrorType ? getErrorType('message') : null
          const errType = errPattern ? Ty.create(errPattern) : null
          const errDesc = errType ? this.parser.describe(errType) : null
          const errText = errDesc ? stringify(errDesc) : ''

          const errorsMappingText = stringify({
            ...globalErrorMapping,
            ...errorMapping,
          })

          const url = (basePath ? basePath : '') + path

          return {
            name,
            description,
            method,
            path: url,
            request: reqText,
            response: resText,
            error: errText,
            errors: errorsMappingText,
          }
        }),
      }
    })

    const app = express()

    app.use('/vue', express.static(path.resolve(__dirname, 'node_modules/vue/dist/vue.js')))
    app.use('*', (req, res) => {
      fs.readFile(path.resolve(__dirname, 'doc.html'), (error, buffer) => {
        let text = buffer.toString()
        text = text.replace(/__TITLE__/g, title)
        text = text.replace(/__DESCRIPTION__/g, description)
        const html = text.replace('__DATA__', JSON.stringify(data))
        res.type('html')
        res.send(html)
      })
    })
    app.listen(port)
  }
}

module.exports = Service
